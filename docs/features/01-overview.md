# FlowMind 核心功能详解

FlowMind 是一个 AI 驱动的工作流智能体，提供 5 大核心创新功能，旨在成为你的主动工作流伴侣。

---

## 功能概览

| 功能 | 优先级 | 核心价值 |
|------|--------|----------|
| 智能工作流发现引擎 | ⭐ | 自动发现可优化的重复操作 |
| 实时 AI 助手面板 | ⭐⭐ | 上下文感知的即时帮助 |
| 智能剪藏与知识图谱 | ⭐⭐⭐ | AI 驱动的知识管理系统 |
| 工作流可视化仪表板 | ⭐⭐ | 清晰了解时间分配 |
| 智能任务自动化引擎 | ⭐⭐⭐ | 自然语言生成自动化脚本 |

---

## 1. 智能工作流发现引擎 ⭐

### 解决的问题

用户不知道哪些日常操作可以自动化，往往重复执行相同的操作序列而未意识到优化的可能性。

### 解决方案

AI 自动识别重复性操作模式，并主动建议自动化方案。

### 工作原理

```
监控层 → 事件序列分析 → 模式识别 → AI 理解 → 自动化建议
```

### 具体使用场景

**场景：开发环境启动自动化**

1. **观察期**
   - 你每天早上都执行：`打开 VS Code → 打开终端 → cd 到项目 → npm run dev`
   - FlowMind 在后台静默记录这些操作

2. **模式识别**
   - FlowMind 检测到这个模式（连续 3 次出现）
   - 系统标记为潜在的自动化候选

3. **AI 分析**
   - AI 生成智能建议："我注意到你每天都会重复这个启动流程，要一键自动化吗？"
   - 展示即将执行的操作步骤，供用户确认

4. **自动化生成**
   - 你点击"是"
   - FlowMind 自动生成 Shell/AppleScript 脚本
   - 创建快捷键或菜单项

5. **享受便利**
   - 下次只需一个快捷键，全部自动完成

### 技术实现

#### 事件序列存储
- **存储方式**：SQLite 数据库
- **记录内容**：
  - 应用切换事件
  - 快捷键触发
  - 剪贴板内容
  - 文件操作
  - 时间戳和上下文信息

#### 序列模式挖掘
- **算法选择**：PrefixSpan 或 SPADE 算法
- **目标**：识别频繁出现的操作序列
- **参数**：
  - 最小支持度（minSupport）：默认 3 次
  - 时间窗口：默认 30 分钟
  - 最大序列长度：默认 10 步

#### AI 理解与过滤
- **目的**：判断哪些模式真正值得自动化
- **考虑因素**：
  - 执行频率
  - 操作复杂度
  - 时间节省潜力
  - 用户上下文（工作/休息时间）

#### 脚本生成
- **支持语言**：
  - Shell脚本（Bash/Zsh）
  - Python 脚本
  - AppleScript（macOS 自动化）
  - Go 程序
- **生成策略**：
  - 优先使用 Shell（简单高效）
  - 复杂逻辑使用 Python
  - macOS 系统集成使用 AppleScript

### 用户界面设计

```
┌─────────────────────────────────────┐
│  💡 发现新的自动化机会              │
├─────────────────────────────────────┤
│  模式：每日开发环境启动              │
│  频率：连续 5 天，每天 1 次          │
│                                     │
│  操作步骤：                          │
│  1. 打开 VS Code                    │
│  2. 打开 Terminal，cd ~/projects/x  │
│  3. 执行 npm run dev                │
│                                     │
│  预计节省时间：每次 2 分钟           │
│                                     │
│  [创建自动化]  [忽略]  [稍后提醒]    │
└─────────────────────────────────────┘
```

---

## 2. 实时 AI 助手面板 ⭐⭐

### 解决的问题

传统 AI 助手需要切换窗口，打乱用户的工作流和心流状态。

### 解决方案

全局快捷键唤起的半透明面板，AI 理解当前上下文并主动提供帮助。

### 核心特性

#### 全局快捷键
- **默认快捷键**：`Cmd+Shift+M`（可自定义）
- **响应时间**：< 100ms
- **视觉效果**：半透明毛玻璃效果，不遮挡全部内容

#### 上下文感知
AI 知道：
- 你当前使用哪个应用
- 当前编辑的文件是什么
- 你选中的文本内容
- 你最近进行的操作
- 当前剪贴板内容

#### 智能建议
基于当前状态主动提供：
- 代码模板和片段
- 相关文档和教程
- 常见错误和解决方案
- 可执行的自动化脚本

### 具体使用场景

**场景 1：React 代码助手**

```javascript
// 你正在 VS Code 中写 React 代码
// 按 Cmd+Shift+M，面板出现

AI: 我注意到你在写 useEffect，需要帮助吗？
    [1] 生成 useEffect 模板
    [2] 检查依赖项完整性
    [3] 查看最佳实践
    [4] 解释常见陷阱
    [5] 自定义问题...

// 你选择 1，AI 直接在当前光标位置插入代码
useEffect(() => {
  // 你的 effect 逻辑
  return () => {
    // 清理函数
  };
}, [/* 依赖项 */]);
```

**场景 2：调试助手**

```python
# 你在 Python 代码中遇到错误
# 选中错误信息，按 Cmd+Shift+M

AI: 我看到这个错误，可能是以下原因：

    1. 变量未定义
       ↑ StackOverflow: 最相关的解答

    2. 导入缺失
       ↑ 官方文档链接

    3. 类型不匹配
       ↑ 类似问题的 GitHub 讨论

    [在光标处插入修复代码]
```

**场景 3：文档速查**

```bash
# 你在写 Git 命令但忘了具体语法
# 输入 "git reb"，按 Cmd+Shift+M

AI: 你在找 Git rebase 命令吗？

    常用用法：
    1. git rebase -i HEAD~3   # 交互式 rebase
    2. git rebase main        # rebase 到 main
    3. git rebase --continue  # 继续 rebase

    [直接插入命令 1] [查看完整教程]
```

### 技术实现

#### 全局快捷键
- **Go 库**：`github.com/bertnm/gr-hotkey` 或 `github.com/go-vgo/robotgo`
- **实现方式**：
  - 注册全局热键监听
  - 触发时唤起 Wails 窗口
  - 窗口置顶并获取焦点

#### 应用上下文获取
- **macOS Accessibility API**
  - 获取前台应用：`NSWorkspace.shared.frontmostApplication`
  - 获取窗口标题：`AXFocusedWindowAttribute`
  - 获取选中文本：`AXFocusedUIElementAttribute`
  - 获取文件路径：通过应用特定 API

#### AI 对话
- **集成**：Claude API
- **流式响应**：Server-Sent Events (SSE)
- **上下文构建**：
  - 当前应用和文件
  - 选中的文本内容
  - 最近操作历史（最近 5 个事件）
  - 用户偏好和历史对话

#### 代码注入
- **方法 1：键盘模拟**
  - `robotgo.TypeStr()` - 模拟键盘输入
  - 适用于大多数应用

- **方法 2：AppleScript**
  - 直接操作应用内部
  - 适用于支持 AppleScript 的应用（VS Code、Terminal）

- **方法 3：剪贴板粘贴**
  - 将内容写入剪贴板
  - 模拟 Cmd+V 粘贴
  - 兜底方案

### 用户界面设计

```
┌──────────────────────────────────────────────┐
│  🤖 FlowMind Assistant             [_][□][X] │
├──────────────────────────────────────────────┤
│                                              │
│  上下文：VS Code - App.tsx                  │
│                                              │
│  AI: 我注意到你在写 React 组件，我可以帮你：  │
│                                              │
│  [1] 生成组件模板            ┌───────────┐  │
│  [2] 添加 PropTypes           │           │  │
│  [3] 优化性能（useMemo）      │  对话区  │  │
│  [4] 添加测试代码             │           │  │
│  [5] 自定义问题...           └───────────┘  │
│                                              │
│  [输入问题...]                     [发送]    │
└──────────────────────────────────────────────┘
```

---

## 3. 智能剪藏与知识图谱 ⭐⭐⭐

### 解决的问题

传统剪藏工具：
- 内容容易堆积，难以整理
- 缺乏智能分类和标签
- 无法建立知识间的关联
- 检索困难，利用价值低

### 解决方案

AI 自动分类、打标签、建立关联，构建智能知识图谱，实现语义检索和主动推荐。

### 工作流程

```
剪藏（选区/快捷键）
    ↓
AI 理解内容 + 上下文
    ↓
自动分类 + 打标签 + 生成摘要
    ↓
向量化存储
    ↓
知识图谱建立关联
    ↓
需要时智能检索推荐
```

### 具体使用场景

**场景：技术知识积累**

1. **剪藏时刻**
   - 你看到一篇关于 Rust 异步编程的文章
   - 选中关键段落，按 `Cmd+Shift+S`
   - 或点击浏览器扩展的"剪藏到 FlowMind"

2. **AI 自动分析**
   ```
   标签：#rust #async #programming #backend
   分类：技术文档 / Rust / 异步编程
   摘要：Rust 的 async/await 与 JavaScript 的区别...
     • Rust 使用 Future 惰性求值
     • JavaScript 的 Promise 是热执行
     • Tokio 运行时的调度策略...
   ```

3. **知识关联**
   - AI 检测到与你之前剪藏的"Tokio 运行时"文章相关
   - 自动建立双向链接
   - 在知识图谱中显示关联节点

4. **智能推荐（3 天后）**
   - 你在 VS Code 中写 Rust 代码
   - FlowMind 检测到上下文
   - 通知："记得你剪藏过 Rust 异步编程的文章，需要查看吗？"
   - 点击即可打开完整内容

### 技术实现

#### 文本理解
- **Claude API**：生成标签和摘要
- **分析维度**：
  - 主题分类（技术/设计/产品等）
  - 关键词提取
  - 情感分析（正面/负面/中性）
  - 难度评估（入门/进阶/专家）
  - 相关领域识别

#### 向量化
- **向量数据库**：chromem-go（本地优先）
- **Embedding 模型**：
  - 默认：Ollama 的 nomic-embed-text
  - 可选：OpenAI text-embedding-3-small
- **向量维度**：768 或 1536
- **索引方式**：HNSW（近似最近邻）

#### 语义搜索
- **算法**：余弦相似度匹配
- **检索流程**：
  1. 用户输入查询或提供上下文
  2. 将查询向量化
  3. 计算与所有文档的相似度
  4. 返回 Top-K 相关内容
- **混合检索**：
  - 语义搜索 + 关键词匹配
  - 时间衰减因子
  - 用户反馈调整排序

#### 知识图谱
- **存储方案**：
  - 轻量级：SQLite + 图算法库
  - 专业级：Neo4j（可选插件）
- **节点类型**：
  - 文档节点
  - 标签节点
  - 概念节点
  - 作者节点
- **边关系**：
  - 文档-标签：hasTag
  - 文档-文档：relatedTo、references
  - 标签-标签：similarTo
- **可视化**：
  - 使用 D3.js 或 Cytoscape.js
  - 力导向布局
  - 交互式探索

#### 上下文触发
- **监听机制**：
  - 应用切换事件
  - 文件类型检测
  - 关键词匹配
- **推荐策略**：
  - 实时语义匹配
  - 时间窗口（最近 7 天的剪藏优先）
  - 用户反馈学习（点击/忽略）

### 用户界面设计

#### 剪藏界面
```
┌─────────────────────────────────────┐
│  📎 剪藏到 FlowMind                  │
├─────────────────────────────────────┤
│  标题：Rust 异步编程深入理解         │
│  来源：https://example.com/rust-async│
│                                     │
│  AI 分析中... ✓                     │
│                                     │
│  标签：                              │
│  [#rust] [#async] [#backend]        │
│  [+ 添加标签]                        │
│                                     │
│  摘要：                              │
│  Rust 的 async/await 与 JavaScript   │
│  的区别主要体现在 Future 的惰性求值  │
│  和运行时调度策略上...               │
│                                     │
│  [保存] [保存并编辑] [取消]          │
└─────────────────────────────────────┘
```

#### 知识图谱界面
```
┌─────────────────────────────────────┐
│  🧠 知识图谱                  [搜索] │
├─────────────────────────────────────┤
│                                     │
│     [Rust] ──── [Tokio]             │
│        │           │                │
│        │           │                │
│     [async] ─── [Future]            │
│        │                            │
│        │                            │
│     [我的文章1]                     │
│                                     │
│  点击节点查看详情                    │
│  滚轮缩放，拖拽移动                  │
└─────────────────────────────────────┘
```

---

## 4. 工作流可视化仪表板 ⭐⭐

### 解决的问题

用户不知道时间都去哪了，无法量化自己的工作模式和效率瓶颈。

### 解决方案

漂亮的数据可视化仪表板，多维度展示工作流数据，提供 AI 洞察和优化建议。

### 仪表板功能

#### 📈 时间分布图
- **维度**：
  - 按应用统计
  - 按项目统计（自动识别）
  - 按任务类型（编码/会议/文档等）
- **可视化**：
  - 饼图：今日应用占比
  - 柱状图：一周趋势
  - 热力图：24 小时活动分布

#### 🔄 工作流图
- **类型**：Sankey 图（桑基图）
- **展示**：
  - 操作流程（如：VS Code → Browser → Slack → VS Code）
  - 时间跨度
  - 切换频率
- **价值**：发现重复性流程和切换开销

#### 🎯 专注时间分析
- **识别**：
  - 高效时段（连续 25 分钟以上无中断）
  - 心流时段（60 分钟以上深度工作）
  - 碎片化时段（频繁切换）
- **统计**：
  - 平均专注时长
  - 最佳工作时段
  - 干扰事件统计

#### ⚠️ 干扰源识别
- **分类**：
  - 通知类（Slack、邮件）
  - 环境类（同事打断）
  - 自发类（切换到社交媒体）
- **统计**：
  - 打断次数
  - 恢复时间
  - 主要干扰源排名

#### 💡 AI 洞察
- **分析内容**：
  - 工作模式总结
  - 效率瓶颈识别
  - 优化建议
- **示例**：
  - "你的高效时段是 9:00-11:30，建议安排最重要的任务"
  - "Slack 打断了你 12 次专注工作，建议开启专注模式"
  - "周五下午你经常浏览社交媒体，可能需要休息"

### 具体使用场景

**场景：每日工作流分析**

```
┌──────────────────────────────────────────────┐
│  📊 今日工作流分析          2026-01-28 周二   │
├──────────────────────────────────────────────┤
│                                              │
│  应用时间分布：                               │
│  VS Code     4h 32m  ████████████ 45%       │
│  Browser     2h 15m  ██████       23%       │
│  Terminal    1h 45m  ████         18%       │
│  Slack         45m  ██           9%        │
│  Figma         30m  █            5%        │
│                                              │
│  工作流图：                                   │
│  [VS Code] → [Browser] → [VS Code]          │
│     │              │                         │
│     ↓              ↓                         │
│  [Terminal]     [Slack]                      │
│                                              │
│  专注时段：                                   │
│  09:00-11:30  🎯 高效时段 (2.5h)            │
│  14:00-15:15  ⚡ 碎片化 (多次中断)           │
│  15:30-17:00  💪 深度工作 (1.5h)            │
│                                              │
│  💡 AI 洞察：                                │
│  • 你的高效时段是 9:00-11:30                 │
│  • Slack 打断了你 12 次专注工作              │
│  • 建议开启专注模式，延迟通知到 12:00        │
│  • 下午 3 点后效率下降，可能需要短暂休息      │
└──────────────────────────────────────────────┘
```

### 技术实现

#### 数据收集
- **后台进程**：记录应用切换
- **API**：`NSWorkspace.shared.frontmostApplication`
- **采样频率**：每 5 秒
- **隐私保护**：
  - 仅记录应用名称
  - 不记录窗口内容
  - 用户可选择暂停

#### 数据存储
- **SQLite**：时间序列数据
- **表结构**：
  - `app_sessions`：应用使用时段
  - `events`：所有事件
  - `categories`：应用分类（开发/通讯/娱乐等）

#### 可视化
- **前端方案**：
  - ECharts（功能丰富，中文友好）
  - D3.js（高度自定义）
- **后端方案**（可选）：
  - `github.com/wcharczuk/go-chart`：静态图表
  - 生成图片传输给前端

#### AI 分析
- **Claude API**：生成洞察建议
- **提示词策略**：
  - 提供聚合后的数据（不泄露隐私）
  - 请求 3-5 条关键洞察
  - 优先给出可执行建议
- **缓存**：
  - 同一时间段的分析结果缓存 1 小时
  - 避免频繁调用 API

---

## 5. 智能任务自动化引擎 ⭐⭐⭐

### 解决的问题

现有自动化工具：
- 学习曲线陡峭
- 需要编程知识
- 无法理解自然语言
- 缺乏智能上下文

### 解决方案

自然语言描述需求，AI 理解意图、生成脚本、安全执行，并支持定时和触发器。

### 工作流程

```
你："每天下午 5 点，总结我今天写的代码并发到 Slack"
    ↓
AI 理解意图 → 分析可行方案 → 生成脚本
    ↓
AI 展示计划：
  • 使用 Git API 获取今日提交
  • 用 Claude API 生成摘要
  • 调用 Slack Webhook 发送
    ↓
你确认 → AI 执行 → 设置定时任务
    ↓
每天自动执行，可随时查看日志
```

### 支持的自动化类型

#### 文件操作
- 监控文件夹变化
- 自动整理下载文件夹
- 批量重命名
- 文件格式转换

#### Git 操作
- 自动 commit（基于规则）
- 定时 push
- 自动生成 PR
- 生成 changelog

#### 通知发送
- Slack/Discord/Email/Telegram
- 自定义消息模板
- 条件触发（失败/成功）

#### 应用联动
- 切换应用
- 执行 AppleScript
- 模拟键盘输入
- 剪贴板操作

#### 数据处理
- 调用 AI 处理文本
- 代码分析
- 数据提取和转换

### 具体使用场景

**场景 1：每日代码总结**

```
用户输入：
"每天下午 5 点，总结我今天写的代码并发到 #dev 频道"

AI 响应：
我理解了你的需求，这是执行计划：

步骤 1: 获取今天的 Git 提交
  命令: git log --since="today 00:00" --pretty=format:"%h %s"
  目录: ~/projects/flowmind

步骤 2: 使用 AI 生成摘要
  输入: 今天的提交记录
  提示: 总结今日开发进展，列出主要改动

步骤 3: 发送到 Slack
  Webhook: https://hooks.slack.com/services/...
  频道: #dev
  模板:
    📅 今日开发总结 - {date}
    {summary}

定时: 0 17 * * 1-5 (工作日 17:00)

[立即测试] [确认创建] [修改计划]
```

**场景 2：智能文件整理**

```
用户输入：
"把下载文件夹里的图片按月份整理到 Pictures/2026/01/"

AI 响应：
我理解了你的需求，这是执行计划：

步骤 1: 扫描下载文件夹
  目标: ~/Downloads/
  过滤: *.jpg, *.png, *.heic
  条件: 创建时间在本月

步骤 2: 创建目标文件夹
  路径: ~/Pictures/2026/01/
  命令: mkdir -p ~/Pictures/2026/01/

步骤 3: 移动文件
  操作: mv ~/Downloads/image.jpg ~/Pictures/2026/01/
  策略: 重名时添加序号

触发器: 文件夹监控
  监控: ~/Downloads/
  条件: 新增图片文件
  延迟: 5 秒（确保下载完成）

[立即测试] [确认创建] [修改计划]
```

**场景 3：会议助手**

```
用户输入：
"日历有会议时，提前 5 分钟提醒我，并自动打开 Zoom 链接"

AI 响应：
我理解了你的需求，这是执行计划：

步骤 1: 监控日历事件
  源: macOS Calendar.app
  API: EventKit
  查询: 未来 24 小时的事件

步骤 2: 提前 5 分钟提醒
  触发: 当前时间 = 事件开始 - 5 分钟
  动作: 显示桌面通知

步骤 3: 提取并打开 Zoom 链接
  解析: 事件描述和位置
  匹配: zoom.us/j/*
  打开: open zoom_url

定时: 每分钟检查

[立即测试] [确认创建] [修改计划]
```

### 技术实现

#### NLU 意图识别
- **Claude API**：解析自然语言
- **提取信息**：
  - 动作（总结/整理/提醒）
  - 对象（代码/文件/会议）
  - 触发条件（时间/事件）
  - 目标（Slack/文件夹）
- **结构化输出**：
  - JSON 格式的执行计划
  - 步骤列表和参数

#### 脚本生成
- **支持语言**：
  - Go（主要，类型安全）
  - Shell（简单任务）
  - Python（数据处理）
- **生成策略**：
  - 使用代码模板
  - AI 填充具体逻辑
  - 类型检查和验证

#### 沙箱执行
- **资源限制**：
  - CPU: 单核
  - 内存: 100MB
  - 超时: 30 秒
- **权限控制**：
  - 白名单目录
  - 只读文件系统（部分）
  - 禁止网络访问（可选）
- **用户确认**：
  - 首次执行必须确认
  - 显示详细操作步骤
  - 可审计的日志

#### 任务调度
- **cron 表达式**：
  - 标准格式：`* * * * *`
  - 可视化编辑器
- **事件触发**：
  - 文件系统变化
  - 应用切换
  - 自定义事件
- **调度器**：`github.com/robfig/cron`

### 用户界面设计

#### 自动化编辑器
```
┌──────────────────────────────────────────────┐
│  ⚙️ 自动化编辑器              [保存] [运行]  │
├──────────────────────────────────────────────┤
│  名称: 每日代码总结                           │
│  描述: 总结今天的 Git 提交并发送到 Slack      │
│                                              │
│  触发器:                                     │
│  ○ 定时任务  ○ 事件触发  ● 混合             │
│    Cron: 0 17 * * 1-5    [工作日 17:00]     │
│                                              │
│  执行步骤:                                   │
│  1. [Git] 获取今日提交                       │
│     └─ 目录: ~/projects/flowmind             │
│  2. [AI] 生成摘要                            │
│     └─ 提示: 总结开发进展，列出主要改动       │
│  3. [Slack] 发送消息                         │
│     └─ 频道: #dev                           │
│                                              │
│  [+ 添加步骤]                                │
│                                              │
│  日志:                                       │
│  [2026-01-28 17:00] ✓ 成功                  │
│  [2026-01-27 17:00] ✓ 成功                  │
│  [查看完整日志]                              │
└──────────────────────────────────────────────┘
```

---

## 功能优先级说明

- ⭐⭐⭐ **核心价值功能**：差异化的核心竞争力
- ⭐⭐ **重要功能**：显著提升用户体验
- ⭐ **增强功能**：锦上添花，可以后期迭代

**建议实施顺序**：
1. Phase 1-2: 智能工作流发现引擎（⭐）
2. Phase 3: 实时 AI 助手面板（⭐⭐）
3. Phase 4: 智能剪藏与知识图谱（⭐⭐⭐）
4. Phase 5: 智能任务自动化引擎（⭐⭐⭐）
5. Phase 6: 工作流可视化仪表板（⭐⭐）

---

**相关文档**：
- [差异化优势](./02-competitive-advantage.md)
- [系统架构](../architecture/01-system-architecture.md)
- [实施路线图](../implementation/README.md)
